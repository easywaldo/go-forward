---
layout: post
title: "이벤트소싱과 마이크로서비스 아키텍쳐 스터디"
date: 2025-07-11 14:30:00 +0900
categories: [tech]
tags: [DDD, 도메인주도설계, 마이크로서비스, 아키텍쳐, 스터디]
excerpt: "도메인 주도 설계(DDD)에 대한 스터디 내용을 정리하고 핵심 개념들을 살펴보겠습니다."
---

# 제1장 : 도메인 주도 설계

>도메인 주도 설계(Domain-Driven Design, DDD)에 대한 스터디 내용을 정리해보겠습니다.

## 관심사의 분리

예를 들어 예약시스템에서의 결제와 지불시스템에서의 결제의 의미가 서로 다릅니다.

- **예약시스템의 결제**: 예약 완료를 위한 결제 행위
- **지불시스템의 결제**: 실제 금전 거래 처리

각 도메인에서 같은 용어라도 다른 의미와 책임을 가지므로 명확한 관심사 분리가 필요합니다.

## 도메인 로직 패턴들의 구성

도메인 로직 패턴들을 어떻게 구성하는 것이 적절한지 고민해야 합니다.

- **트랜잭션 스크립트**: 단순한 비즈니스 로직
- **도메인 모델**: 복잡한 비즈니스 로직을 객체로 표현
- **테이블 모듈**: 데이터베이스 테이블 중심의 설계

## 예외 클래스 설계 접근법

구체적인 이름으로 수식이 된 예외클래스 VS 범용적인 명사로 이뤄진 예외클래스

```java
// 구체적인 예외 클래스
public class NotFoundPaymentException extends RuntimeException {
    // 구체적인 의미를 담은 예외
}

// 범용적인 예외 클래스
public class PaymentException extends RuntimeException {
    private final ErrorCode errorCode;
    
    public PaymentException(ErrorCode errorCode) {
        this.errorCode = errorCode;
    }
}
```

각각의 장단점을 고려하여 프로젝트 상황에 맞는 선택이 필요합니다.

## 엔터티와 VO의 차이

**엔터티(Entity)**는 고유한 식별이 가능한 개체로서 인식 가능한 개념이며, **값객체(Value Object)**는 엔터티를 수식해줄 수 있는 역할이 적합한 개체입니다.

또한 이러한 값객체는 불변하며 변경이 되어야 할 경우 직접 변경이 아닌 엔터티를 통한 변경이 이뤄져야 합니다.

```java
// 엔터티 예시
public class User {
    private final UserId id;  // 고유 식별자
    private UserName name;    // 값객체
    private Email email;      // 값객체
}

// 값객체 예시
public class Email {
    private final String value;
    
    public Email(String value) {
        // 불변 객체로 생성
        this.value = validate(value);
    }
}
```

## 도메인 주도 설계에서의 서비스의 종류

DDD에서는 세 가지 종류의 서비스가 있습니다:

### 1. 인프라스트럭쳐 서비스
- 외부 시스템과의 연동
- 데이터베이스 접근
- 메시징 시스템 등

### 2. 어플리케이션 서비스
- 유스케이스 조율
- 트랜잭션 관리
- 보안 처리

### 3. 도메인 서비스
- 도메인 로직 처리
- 여러 엔터티 간의 복잡한 비즈니스 규칙

## 에릭에반스와 반버논의 도메인서비스 사용에 대한 상반된 시각

- **에릭 에반스**: 도메인 서비스 사용을 권장하되 신중하게 사용
- **반 버논**: 도메인 서비스 사용을 최소화하고 엔터티/값객체 중심으로 설계

## 도메인 서비스의 역할

### 1. 객체간의 관계와 규칙을 설정
엔터티 간의 복잡한 비즈니스 규칙을 처리합니다.

### 2. 타입의 변환
- 도메인 객체를 DTO로 변환
- 도메인 객체를 다른 도메인 객체로 변환
- 엔터티 객체를 값객체로 변환
- DTO를 도메인 객체로 변환

### 3. 도메인 객체간의 계산 로직 수행
여러 도메인 객체를 사용하는 복잡한 계산 로직을 처리합니다.

## 도메인 서비스 명명 사례

도메인 서비스의 명명은 다음과 같은 패턴을 따를 수 있습니다:

- `PaymentCalculator`: 결제 계산 로직
- `OrderValidator`: 주문 검증 로직
- `UserRegistrationService`: 사용자 등록 서비스

## 에그리게이트 설계 규칙

1. **일관성 경계 정의**: 트랜잭션 범위와 일치
2. **루트 엔터티 선정**: 외부에서 접근 가능한 단일 진입점
3. **크기 최소화**: 성능과 확장성을 고려한 적절한 크기

## 에그리게이트 인스턴스 생성 위치

에그리게이트는 다음 위치에서 인스턴스를 생성하는 것이 적절합니다:

- **팩토리 메서드**: 복잡한 생성 로직
- **리포지토리**: 데이터 저장소에서 복원
- **어플리케이션 서비스**: 유스케이스 처리 중

## Domain Repository란?

도메인 리포지토리는 도메인 객체의 영속성을 추상화한 인터페이스입니다.

```java
public interface UserRepository {
    User findById(UserId id);
    void save(User user);
    void delete(UserId id);
}
```

## Abstract Core

시스템의 핵심 도메인 로직을 추상화한 개념으로, 구체적인 구현에 의존하지 않는 핵심 비즈니스 규칙을 나타냅니다.

## 빌딩블록(Building Blocks)

에릭 에반스는 도메인 모델을 작성할 때 사용할 수 있는 기본적인 빌딩 블록을 정의 하였습니다.

DDD에서 도메인 모델을 구성하는 기본 구성 요소들:

- **엔터티(Entity)**: 고유 식별자를 가진 객체
- **값객체(Value Object)**: 속성으로만 식별되는 불변 객체
- **집합체(Aggregate)**: 일관성 경계를 가진 객체들의 집합
- **도메인 서비스(Domain Service)**: 도메인 로직을 처리하는 서비스
- **리포지토리(Repository)**: 도메인 객체의 영속성 추상화
- **팩토리(Factory)**: 복잡한 객체 생성 로직

### 빌딩블록과 의존 관계

```
┌────────────────────────────┐              ┌────────────────────────────┐
│      인바운드 어댑터           │              │      아웃바운드 어댑터         |
│                            │              │                            |
│  • REST API                │              │  • 데이터베이스               |
│  • gRPC                    │              │  • 외부 API, gRPC           |
│  • 메시지 큐                 │              │  • 파일 시스템                │
└────────────────────────────┘              └────────────────────────────┘

         │                                                      ▲
         │                                                      │
         ▼                                                      │
┌───────────────────────────────────────────────────────────────────────┐
│                               어플리케이션서비스                           │     │                                                                       │
│  • 유스케이스 조율                                                        │
│  • 트랜잭션 관리                                                         │
│  • 보안 처리                                                            │
│  • 도메인 객체 생성/조회                                                   │
└───────────────────────────────────────────────────────────────────────┘
         │                                              │
         │                                              │
         ▼                                              ▼
┌─────────────────┐                             ┌─────────────────┐
│    도메인 객체     │                             │    리포지토리     │
│                 │                             │                │
│  • 엔터티         │                             │  • 영속성 추상화  │
│  • 값객체         │                             │  • 도메인 중심   │
│  • 집합체         │                             │  • 인터페이스    │
│  • 도메인 서비스    │                            │                │
└─────────────────┘                             └─────────────────┘
```

### 의존 관계 설명

1. **인바운드 어댑터 → 어플리케이션 서비스**
   - 외부 요청을 어플리케이션 서비스로 전달
   - REST API, gRPC, 메시지 큐 등

2. **어플리케이션 서비스 → 도메인 객체**
   - 비즈니스 로직 실행을 위해 도메인 객체 사용
   - 엔터티, 값객체, 집합체, 도메인 서비스 활용

3. **어플리케이션 서비스 → 리포지토리**
   - 도메인 객체의 영속성 처리
   - 데이터 조회, 저장, 삭제

4. **어플리케이션 서비스 ← 아웃바운드 어댑터**
   - 외부 시스템과의 연동
   - 데이터베이스, 외부 API, gRPC, 메시지 큐, 파일 시스템 등

이러한 구조를 통해 도메인 로직을 중심으로 한 깔끔한 아키텍처를 구성할 수 있습니다.



---

*이 스터디 내용이 도움이 되었나요? 댓글로 의견을 남겨주세요!*
